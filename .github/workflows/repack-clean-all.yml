name: Universal OpenWrt Repack (All-in-One)

on:
#  schedule:
#    - cron: '0 2 * * *' # æ¯å¤© UTC 2:00 (åŒ—äº¬æ—¶é—´ 10:00) è‡ªåŠ¨è¿è¡Œ
  workflow_dispatch:
    inputs:
      plugin_name:
        description: 'Select Plugin to Repack'
        required: true
        default: 'All'
        type: choice
        options:
          - All
          - Nikki
          - Passwall
          - Passwall2
          - DDNS-Go
          - Argon-Theme
          - OpenClash
          - HomeProxy
          - Dockerman
          - iStore
      tag_name:
        description: 'Target Tag (Leave empty for auto-detect)'
        required: false

# æŽˆäºˆæœ€é«˜æƒé™
permissions:
  contents: write
  actions: write

jobs:
  # ============================================================================
  # ä»»åŠ¡ 1: å…¨å±€å¤§æ‰«é™¤
  # ============================================================================
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: ðŸ—‘ï¸ Delete ALL Completed Workflow Runs
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Fetching list of ALL completed workflow runs..."
          RUN_IDS=$(gh run list --status completed --limit 1000 --json databaseId -q '.[].databaseId' || echo "")
          if [ -n "$RUN_IDS" ]; then
            for RUN_ID in $RUN_IDS; do gh run delete "$RUN_ID" || true; done
            echo "âœ… All completed workflow runs cleared."
          fi

      - name: ðŸ—‘ï¸ Delete ALL Existing Releases & Tags
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Fetching all existing releases..."
          TAGS=$(gh release list --limit 1000 --json tagName -q '.[].tagName' || echo "")
          if [ -n "$TAGS" ]; then
            for TAG in $TAGS; do
              gh release delete "$TAG" --cleanup-tag --yes || echo "Warning: Failed to delete $TAG"
            done
            echo "âœ… All old releases cleared."
          fi

  # ============================================================================
  # ä»»åŠ¡ 2: å‡†å¤‡æž„å»ºçŸ©é˜µ
  # ============================================================================
  matrix_prep:
    needs: cleanup
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - id: set-matrix
        run: |
          # å®šä¹‰æ‰€æœ‰æ’ä»¶æº
          # æ³¨æ„ï¼šArgon, Dockerman, HomeProxy çŽ°åœ¨éƒ½ä½¿ç”¨ IMMORTALWRT_REPO é€»è¾‘
          json_data='[
            {"id": "nikki", "name": "Nikki", "repo": "nikkinikki-org/OpenWrt-nikki", "keyword": "*x86_64*.tar.gz"},
            {"id": "passwall", "name": "Passwall", "repo": "xiaorouji/openwrt-passwall", "keyword": "*packages*ipk*x86_64*.zip"},
            {"id": "passwall2", "name": "Passwall2", "repo": "xiaorouji/openwrt-passwall2", "keyword": "*packages*ipk*x86_64*.zip"},
            {"id": "ddns-go", "name": "DDNS-Go", "repo": "sirpdboy/luci-app-ddns-go", "keyword": "*"},
            {"id": "argon", "name": "Argon-Theme", "repo": "IMMORTALWRT_REPO", "keyword": "web_scrape"},
            {"id": "openclash", "name": "OpenClash", "repo": "vernesong/OpenClash", "keyword": "*.ipk"},
            {"id": "homeproxy", "name": "HomeProxy", "repo": "IMMORTALWRT_REPO", "keyword": "web_scrape"},
            {"id": "dockerman", "name": "Dockerman", "repo": "IMMORTALWRT_REPO", "keyword": "web_scrape"},
            {"id": "istore", "name": "iStore", "repo": "ISTORE_REPO", "keyword": "web_scrape"}
          ]'

          INPUT_PLUGIN="${{ inputs.plugin_name }}"
          EVENT_NAME="${{ github.event_name }}"
          
          if [ "$EVENT_NAME" == "schedule" ] || [ "$INPUT_PLUGIN" == "All" ] || [ -z "$INPUT_PLUGIN" ]; then
            FINAL_JSON="$json_data"
          else
            case "$INPUT_PLUGIN" in
              "Nikki")       FINAL_JSON='[{"id": "nikki", "name": "Nikki", "repo": "nikkinikki-org/OpenWrt-nikki", "keyword": "*x86_64*.tar.gz"}]' ;;
              "Passwall")    FINAL_JSON='[{"id": "passwall", "name": "Passwall", "repo": "xiaorouji/openwrt-passwall", "keyword": "*packages*ipk*x86_64*.zip"}]' ;;
              "Passwall2")   FINAL_JSON='[{"id": "passwall2", "name": "Passwall2", "repo": "xiaorouji/openwrt-passwall2", "keyword": "*packages*ipk*x86_64*.zip"}]' ;;
              "DDNS-Go")     FINAL_JSON='[{"id": "ddns-go", "name": "DDNS-Go", "repo": "sirpdboy/luci-app-ddns-go", "keyword": "*"}]' ;;
              "Argon-Theme") FINAL_JSON='[{"id": "argon", "name": "Argon-Theme", "repo": "IMMORTALWRT_REPO", "keyword": "web_scrape"}]' ;;
              "OpenClash")   FINAL_JSON='[{"id": "openclash", "name": "OpenClash", "repo": "vernesong/OpenClash", "keyword": "*.ipk"}]' ;;
              "HomeProxy")   FINAL_JSON='[{"id": "homeproxy", "name": "HomeProxy", "repo": "IMMORTALWRT_REPO", "keyword": "web_scrape"}]' ;;
              "Dockerman")   FINAL_JSON='[{"id": "dockerman", "name": "Dockerman", "repo": "IMMORTALWRT_REPO", "keyword": "web_scrape"}]' ;;
              "iStore")      FINAL_JSON='[{"id": "istore", "name": "iStore", "repo": "ISTORE_REPO", "keyword": "web_scrape"}]' ;;
              *)             FINAL_JSON="$json_data" ;;
            esac
          fi

          COMPACT_JSON=$(echo "$FINAL_JSON" | jq -c .)
          echo "matrix={\"include\":$COMPACT_JSON}" >> $GITHUB_OUTPUT

  # ============================================================================
  # ä»»åŠ¡ 3: æ‰§è¡Œæ‰“åŒ…
  # ============================================================================
  repack:
    needs: matrix_prep
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.matrix_prep.outputs.matrix) }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ðŸ“¥ Smart Download (${{ matrix.name }})
        id: process
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          UPSTREAM_REPO: ${{ matrix.repo }}
          KEYWORD: ${{ matrix.keyword }}
          MANUAL_TAG: ${{ inputs.tag_name }}
          PLUGIN_ID: ${{ matrix.id }}
        run: |
          set +o pipefail
          mkdir -p raw_files staging_dir

          # ------------------------------------------------------------------
          # åˆ†æ”¯ A: iStoreOS Repo (iStore)
          # ------------------------------------------------------------------
          if [ "$UPSTREAM_REPO" == "ISTORE_REPO" ]; then
             echo ">>> Mode: iStoreOS Web Scrape..."
             REPO_URL="https://repo.istoreos.com/repo/all/store/"
             TARGETS="luci-app-store luci-lib-taskd luci-lib-xterm taskd"
             
             TEMP_DIR="temp_download"
             mkdir -p "$TEMP_DIR"
             PAGE_CONTENT=$(curl -sL "$REPO_URL")
             
             for TARGET in $TARGETS; do
                echo "--> Hunting for: $TARGET"
                FILE_NAME=$(echo "$PAGE_CONTENT" | grep -oP "href=\"\K${TARGET}[^\"]+\.ipk" | sort -V | tail -n 1)
                if [ -n "$FILE_NAME" ]; then
                   curl -sL -o "$TEMP_DIR/$FILE_NAME" "${REPO_URL}${FILE_NAME}"
                fi
             done
             
             if [ ! -f "$TEMP_DIR"/luci-app-store*.ipk ]; then echo "Error: Main package missing."; exit 1; fi
             VERSION=$(ls "$TEMP_DIR"/luci-app-store*.ipk | grep -oP 'store_\K[0-9.-]+')
             
             cp "$TEMP_DIR"/*.ipk raw_files/
             rm -rf "$TEMP_DIR"
             echo "final_tag=v$VERSION" >> $GITHUB_OUTPUT

          # ------------------------------------------------------------------
          # åˆ†æ”¯ B: ImmortalWrt Repo (HomeProxy, Dockerman, Argon)
          # ------------------------------------------------------------------
          elif [ "$UPSTREAM_REPO" == "IMMORTALWRT_REPO" ]; then
             echo ">>> Mode: ImmortalWrt Web Scrape for $PLUGIN_ID..."
             BASE_URL="https://downloads.immortalwrt.org/releases"
             
             if [ -n "$MANUAL_TAG" ]; then
                RAW_VER="$MANUAL_TAG"
             else
                RAW_VER=$(curl -sL "$BASE_URL/" | grep -oP 'href="\K[0-9]+\.[0-9]+\.[0-9]+' | sort -V | tail -n 1 | tr -d '\r\n[:space:]')
             fi
             if [ -z "$RAW_VER" ]; then echo "Error: Failed to detect version."; exit 1; fi
             
             echo "Target Version: [$RAW_VER]"
             FINAL_TAG="v$RAW_VER"
             PKG_ROOT="$BASE_URL/$RAW_VER/packages/x86_64"
             
             # æ ¹æ® Plugin ID å†³å®šä¸‹è½½æ¸…å•
             if [ "$PLUGIN_ID" == "homeproxy" ]; then
                TARGETS="luci-app-homeproxy luci-i18n-homeproxy-zh-cn sing-box chinadns-ng"
                SUB_DIRS="luci packages base"
             elif [ "$PLUGIN_ID" == "dockerman" ]; then
                TARGETS="luci-app-dockerman luci-i18n-dockerman-zh-cn luci-lib-docker ttyd docker dockerd docker-compose libcap libuv1 libwebsockets-full cgroupfs-mount"
                SUB_DIRS="luci packages base routing"
             elif [ "$PLUGIN_ID" == "argon" ]; then
                TARGETS="luci-theme-argon luci-app-argon-config luci-i18n-argon-config-zh-cn"
                SUB_DIRS="luci packages base"
             fi
             
             TEMP_DIR="temp_download"
             mkdir -p "$TEMP_DIR"
             
             for TARGET in $TARGETS; do
                FOUND_FILE=false
                for SUB in $SUB_DIRS; do
                   SEARCH_URL="$PKG_ROOT/$SUB/"
                   # ä½¿ç”¨ç²¾å‡†åŒ¹é…
                   FILE_NAME=$(curl -sL "$SEARCH_URL" | grep -oP "href=\"\K${TARGET}[_\.][^\"]+\.ipk" | sort -V | tail -n 1 | tr -d '\r\n[:space:]')
                   if [ -n "$FILE_NAME" ]; then
                      echo "    Found $TARGET: $FILE_NAME"
                      curl -sL -o "$TEMP_DIR/$FILE_NAME" "$SEARCH_URL$FILE_NAME"
                      
                      if [ -s "$TEMP_DIR/$FILE_NAME" ]; then
                         FOUND_FILE=true
                         break 
                      fi
                   fi
                done
                if [ "$FOUND_FILE" = "false" ]; then echo "WARNING: '$TARGET' not found."; fi
             done
             
             if [ -z "$(ls -A "$TEMP_DIR")" ]; then echo "Error: Download failed."; exit 1; fi
             cp "$TEMP_DIR"/*.ipk raw_files/
             rm -rf "$TEMP_DIR"
             echo "final_tag=$FINAL_TAG" >> $GITHUB_OUTPUT

          # ------------------------------------------------------------------
          # åˆ†æ”¯ C: GitHub Release Download
          # ------------------------------------------------------------------
          else
             echo ">>> Mode: GitHub Release Download..."
             if [ -n "$MANUAL_TAG" ]; then
               TAGS="$MANUAL_TAG"
             else
               TAGS=$(gh release list --repo $UPSTREAM_REPO --limit 5 --json tagName -q '.[].tagName' || echo "")
             fi
             
             FOUND_VALID=false
             FINAL_TAG=""

             for TAG in $TAGS; do
               TEMP_DIR="temp_$TAG"
               mkdir -p "$TEMP_DIR"
               gh release download "$TAG" --repo "$UPSTREAM_REPO" --pattern "$KEYWORD" --dir "$TEMP_DIR" --clobber 2>/dev/null || true
               case "$UPSTREAM_REPO" in
                 *"passwall"*) gh release download "$TAG" --repo "$UPSTREAM_REPO" --pattern "*luci*.ipk" --dir "$TEMP_DIR" --clobber 2>/dev/null || true ;;
               esac

               if [ -z "$(ls -A "$TEMP_DIR")" ]; then rm -rf "$TEMP_DIR"; continue; fi
               find "$TEMP_DIR" -name "*.zip" -exec unzip -o -q {} -d "$TEMP_DIR" \;
               find "$TEMP_DIR" -name "*.tar.gz" -exec tar xzf {} -C "$TEMP_DIR" \;

               IPK_FILES=$(find "$TEMP_DIR" -name "*.ipk")
               VALID_FILES=$(echo "$IPK_FILES" | grep -vE "aarch64|arm|mips|riscv|i386" || true)
               
               if [ -n "$VALID_FILES" ]; then
                 echo "$VALID_FILES" | while read -r file; do [ -n "$file" ] && cp "$file" raw_files/; done
                 rm -rf "$TEMP_DIR"
                 FOUND_VALID=true
                 FINAL_TAG="$TAG"
                 break
               else
                 rm -rf "$TEMP_DIR"
               fi
             done
             
             if [ "$FOUND_VALID" = "false" ]; then echo "Error: No valid releases found."; exit 1; fi
             echo "final_tag=$FINAL_TAG" >> $GITHUB_OUTPUT
          fi
          
          cp raw_files/*.ipk staging_dir/ 2>/dev/null || true

      - name: ðŸ“¦ Build .run Installer
        id: build
        env:
          PLUGIN_ID: ${{ matrix.id }}
        run: |
          TAG="${{ steps.process.outputs.final_tag }}"
          NAME="${{ matrix.id }}"
          FILENAME="${NAME}-x86_64-installer-${TAG}.run"
          
          cd staging_dir
          if [ -z "$(ls -A *.ipk 2>/dev/null)" ]; then echo "Error: No ipk files to package!"; exit 1; fi
          tar czf ../payload.tar.gz *.ipk
          cd ..
          
          cat << 'EOF' > install_header.sh
          #!/bin/sh
          GREEN='\033[0;32m'
          BLUE='\033[0;34m'
          NC='\033[0m'
          echo -e "${BLUE}=========================================${NC}"
          echo -e "${GREEN}   OpenWrt Auto-Installer (x86_64)      ${NC}"
          echo -e "${BLUE}=========================================${NC}"
          
          TMP_DIR="/tmp/install_temp_$$"
          mkdir -p "$TMP_DIR"
          echo -e "-> Extracting payload..."
          ARCHIVE_START_LINE=$(awk '/^__PAYLOAD_BEGINS__/ {print NR + 1; exit 0; }' "$0")
          tail -n +$ARCHIVE_START_LINE "$0" | tar xz -C "$TMP_DIR"
          if [ $? -ne 0 ]; then echo "Error: Extraction failed."; rm -rf "$TMP_DIR"; exit 1; fi
          
          cd "$TMP_DIR"
          echo -e "-> Installing packages..."
          
          # æ™ºèƒ½è§£é”
          LOCK_FILE="/var/lock/opkg.lock"
          if [ -f "$LOCK_FILE" ]; then
             echo "-> opkg is locked. Waiting max 15s..."
             i=0
             while [ -f "$LOCK_FILE" ] && [ $i -lt 15 ]; do sleep 1; i=$((i+1)); echo -n "."; done
             echo ""
             if [ -f "$LOCK_FILE" ]; then echo "-> Forcing unlock..."; rm -f "$LOCK_FILE"; fi
          fi
          
          # å¼ºåˆ¶å®‰è£…
          opkg install *.ipk --force-overwrite
          STATUS=$?
          
          cd /
          rm -rf "$TMP_DIR"
          
          if [ $STATUS -eq 0 ]; then
            echo -e "${GREEN}SUCCESS!${NC}"
            rm -rf /tmp/luci-modulecache/
            rm -f /tmp/luci-indexcache
            echo "Cache cleared. Please refresh LuCI."
          else
            echo -e "WARNING: opkg reported errors."
            # ç‰¹æ®Šæç¤ºï¼šDockerman
            if [ "$PLUGIN_ID" = "dockerman" ]; then
               echo "NOTE: For Dockerman, ensure your system has kernel support (kmod-docker)."
            fi
          fi
          exit 0
          __PAYLOAD_BEGINS__
          EOF
          
          # åŠ¨æ€æ³¨å…¥ PLUGIN_ID å˜é‡åˆ°è„šæœ¬ä¸­
          sed -i "s/\$PLUGIN_ID/$PLUGIN_ID/g" install_header.sh

          cat install_header.sh payload.tar.gz > "$FILENAME"
          chmod +x "$FILENAME"
          echo "filename=$FILENAME" >> $GITHUB_OUTPUT

      - name: ðŸ•’ Generate Time-Stamped Tag
        id: tag_gen
        run: |
          DATE_STR=$(date +'%Y.%m.%d-%H%M')
          echo "date=$DATE_STR" >> $GITHUB_OUTPUT

      - name: ðŸš€ Create Release (ncipollo)
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ matrix.id }}-${{ steps.process.outputs.final_tag }}_${{ steps.tag_gen.outputs.date }}
          name: ${{ matrix.name }} ${{ steps.process.outputs.final_tag }} (${{ steps.tag_gen.outputs.date }})
          body: "Auto-generated installer for ${{ matrix.name }} version ${{ steps.process.outputs.final_tag }}"
          artifacts: "${{ steps.build.outputs.filename }}"
          token: ${{ secrets.GITHUB_TOKEN }}
          draft: false
          prerelease: false
          makeLatest: true
          allowUpdates: true
